   ### 记录一个死锁引发的程序卡死问题
#### 事情的起因
- 消费者线程emit信号给到主线程中插件管理对象，用于调用opencv的算法（算法以插件形式被插件管理对象存储），由于采用Qt::BlockingQueuedConnection，插件管理对象所在的主线程需要完整执行slot函数，消费者线程才能继续执行下去。
- 消费者线程的操作：在进入临界区（待处理图像队列）时，进行上锁操作，进入临界区，获取待处理图像，emit（Image） to 插件管理对象，随后离开临界区之前释放锁。
- 生产者线程进入临界区后，只进行读图入队列的操作。
- 主界面有一个按钮用于控制算法是否循环运行，当选择循环运行时，生产者消费者线程互斥访问临界区（待处理图像队列）。当选择停止循环运行时，主线程接收到按钮产生的（QAction::triggered），执行相应的slot函数，对临界区进行上锁操作，以此使得生产者消费者线程都进入不了临界区。
- 根据以上设想进行编码，测试后发现程序能循环处理图片，但点击停止循环处理时，主界面卡死。
#### 问题分析
- 打开任务管理器发现进程的cpu和内存占用率并没有很高。
- 猜测可能是死锁导致程序卡死。在上锁操作的前后处打印log定位问题。
- 经过多次试验，在循环运行后停止循环有以下现象：
	- 消费者线程进入临界区，emit操作前一句的log正常打印，emit操作后的log没有打印。
	- 主线程进入了停止循环信号对应的slot函数，尝试对临界区进行上锁操作。
	- 主线程中的插件管理对象的slot函数中的相关log没有打印。
- 可以得到以下结论：
	- 主线程在这个过程中至少要做两件事，一是处理插件管理对象的slot函数，二是处理停止循环信号对应的slot函数。
	- 从打印看，每次主线程都是先进入 “停止循环信号对应的slot函数“，并尝试对临界区上锁，而此时消费者线程已经占用临界区并等待主线程处理完  “插件管理对象的slot函数“，导致主线程在等待消费者线程释放锁，而消费者线程等待主线程执行完“插件管理对象的slot函数“。最终结果是主界面卡死。
#### 问题解决
- 将主线程中的 “停止循环信号对应的slot函数“的上锁操作放入A线程，当让 “停止循环信号对应的slot函数“尽快结束，知道主线程处理完“插件管理对象的slot函数“，消费者线程会释放锁，此时,A线程能够对临界区进行上锁操作，此时生产者和消费者无法进入临界区，实现停止循环运行的功能。
- 另一个方法是将消费者线程中的emit操作移至临界区外。消费者的行为是从队列（临界区）取图，再讲图像传给插件管理对象，可以看到emit操作是可以不用放入临界区代码里的。此时，主线程是否先进入“插件管理对象的slot函数“，对临界区进行上锁无关。
- 第三种方法是让消费者线程在emit操作后等待固定时间，若超出规定时间，则进入某个分支，而不是一直等待。这个实现可能和信号-槽机制有关，暂未实现。
#### 思考
- 为什么每次“插件管理对象的slot函数“都要晚于 “停止循环信号对应的slot函数“执行，正是这一点导致出现死锁。其实不用纠结于这两个哪个的快慢，因为是异步的，所以应该默认他们是可以以任意的排列出现，对于任意一种排列情况程序也必须正常处理。
![[Pasted image 20240113191038.png]]

